;;;---------------interpret provider-------------
(define *val* 'wait)
(define *env* '())
(define *pc* '())
(define *stack* (make-vector 100))
(define *stack-index* 0)
(define *arg1* 'wait)
(define *arg2* 'wait)
(define *fun* 'wait)
(define *exit* 'wait)
(define undefined-value 'undefined)

(define (activation-frame-argument sr i)
  (vector-ref (car sr) i))
(define activation-frame-next cdr)
(define (set-activation-frame-argument! sr j v)
  (vector-set! sr j v))
(define (activation-frame-argument-length v*)
  (vector-length v*))
(define allocate-activation-frame make-vector)
(define (sr-extend* sr v*)
  (cons v* sr))
(define (predefined-fetch i)
  (vector-ref sg.init i) )
(define environment-next cdr)
(define (deep-fetch sr i j)
  (if (= i 0)
      (activation-frame-argument sr j)
      (deep-fetch (environment-next sr) (- i 1) j) ) )
(define (deep-update! sr i j v)
  (if (= i 0)
      (set-activation-frame-argument! sr j v)
      (deep-update! (environment-next sr) (- i 1) j v) ) )
(define (stack-push v)
  (vector-set! *stack* *stack-index* v)
  (set! *stack-index* (+ *stack-index* 1)) )
(define (stack-pop)
  (set! *stack-index* (- *stack-index* 1))
  (vector-ref *stack* *stack-index*) )
(define (restore-stack copy)
  (set! *stack-index* (vector-length copy))
  (vector-copy! copy *stack* 0 *stack-index*) )
(define wrong display)
(define make-closure cons)
(define closure-closed-environment cdr)
(define closure-code car)
(define closure? pair?)
(define continuation-stack 'wait)
(define (listify! v* arity)
  (let loop ((index (- (activation-frame-argument-length v*) 1))
             (result '()) )
    (if (= arity index)
        (set-activation-frame-argument! v* arity result)
        (loop (- index 1)
              (cons (activation-frame-argument v* (- index 1))
                    result ) ) ) ) )
(define (invoke f)
  (cond ((closure? f)
         (stack-push *pc*)
         (set! *env* (closure-closed-environment f))
         (set! *pc* (closure-code f)) )
        ((primitive? f)
         ((primitive-address f)) )
        ((continuation? f)
         (if (= (+ 1 1) (activation-frame-argument-length *val*))
             (begin
               (restore-stack (continuation-stack f))
               (set! *val* (activation-frame-argument *val* 0))
               (set! *pc* (stack-pop)) )
             (wrong "Incorrect arity" 'continuation) ) )
        (else (wrong "Not a function" f)) ) )
(define primitive-address (lambda (v) v))

(define (interpret-provider)
  (set! SHALLOW-ARGUMENT-REF 
        (lambda (j)
          (list (lambda () (set! *val* (activation-frame-argument *env* j)))) ))
  (set! PREDEFINED (lambda (i)
                     (list (lambda () (set! *val* (predefined-fetch i)))) ))
  (set! DEEP-ARGUMENT-REF 
        (lambda (i j)
          (list (lambda () (set! *val* (deep-fetch *env* i j))))))
  (set! SET-SHALLOW-ARGUMENT! 
        (lambda (j)
          (list (lambda () (set-activation-frame-argument! *env* j *val*)))))
  (set! SET-DEEP-ARGUMENT! 
        (lambda (i j)
          (list (lambda () (deep-update! *env* i j *val*)))))
  (set! GLOBAL-REF 
        (lambda (i)
          (list (lambda () (set! *val* (global-fetch i))))))
  (set! CHECKED-GLOBAL-REF 
        (lambda (i)
          (list (lambda () (set! *val* (global-fetch i))
                  (when (eq? *val* undefined-value)
                    (wrong "Uninitialized variable") ))) ))
  (set! SET-GLOBAL! 
        (lambda (i)
          (list (lambda () (global-update! i *val*)))))
  (set! CONSTANT (lambda (value)
                   (list (lambda () (set! *val* value)))))
  (set! JUMP-FALSE 
        (lambda (i)
          (list (lambda () (and (not *val*) (set! *pc* (list-tail *pc* i)))))))
  (set! GOTO (lambda (i)
               (list (lambda () (set! *pc* (list-tail *pc* i))))))
  (set! EXTEND-ENV 
        (lambda ()
          (list (lambda () (set! *env* (sr-extend* *env* *val*))))))
  (set! UNLINK-ENV 
        (lambda ()
          (list (lambda () (set! *env* (activation-frame-next *env*))))))
  (set! CALL0 
        (lambda (address)
          (list (lambda () (set! *val* (address))))))
  (set! INVOKE1 
        (lambda (address)
          (list (lambda () (set! *val* (address *val*))))))
  (set! PUSH-VALUE (lambda ()
                     (list (lambda () (stack-push *val*)))))
  (set! POP-ARG1 (lambda ()
                   (list (lambda () (set! *arg1* (stack-pop))))))
  (set! INVOKE2 (lambda (address)
                  (list (lambda () (set! *val* (address *arg1* *val*))))))
  (set! POP-ARG2 (lambda ()
                   (list (lambda () (set! *arg2* (stack-pop)))) ))
  (set! INVOKE3 (lambda (address)
                  (list (lambda () (set! *val* (address *arg1* *arg2* *val*))))))
  (set! CREATE-CLOSURE 
        (lambda (offset)
          (list (lambda () (set! *val* (make-closure (list-tail *pc* offset) 
                                                     *env* )))) ))
  (set! ARITY=? (lambda (arity+1)
                  (list (lambda () 
                          (unless (= (activation-frame-argument-length *val*) arity+1)
                            (wrong "Incorrect arity") ) )) ))
  (set! RETURN (lambda ()
                 (list (lambda () (set! *pc* (stack-pop))))))
  (set! PACK-FRAME! (lambda (arity)
                      (list (lambda () (listify! *val* arity)))))
  (set! ARITY>=? 
        (lambda (arity+1)
          (list (lambda () 
                  (unless (>= (activation-frame-argument-length *val*) arity+1)
                    (wrong "Incorrect arity") ) )) ))
  (set! POP-FUNCTION (lambda ()
                       (list (lambda () (set! *fun* (stack-pop)))) ))
  (set! FUNCTION-INVOKE (lambda ()
                          (list (lambda () (invoke *fun*))) ))
  (set! PRESERVE-ENV (lambda ()
                       (list (lambda () (stack-push *env*))) ))
  (set! RESTORE-ENV (lambda ()
                      (list (lambda () (set! *env* (stack-pop))))))
  (set! POP-FRAME! 
        (lambda (rank)
          (list (lambda () (set-activation-frame-argument! *val* rank (stack-pop))))))
  (set! POP-CONS-FRAME! 
        (lambda (arity)
          (list (lambda () 
                  (set-activation-frame-argument! 
                   *val* arity (cons (stack-pop)
                                     (activation-frame-argument *val* arity)))))))
  (set! ALLOCATE-FRAME 
        (lambda (size)
          (let ((size+1 (+ size 1)))
            (list (lambda () (set! *val* (allocate-activation-frame size+1)))))))
  (set! ALLOCATE-DOTTED-FRAME 
        (lambda (arity)
          (let ((arity+1 (+ arity 1)))
            (list (lambda ()
                    (let ((v* (allocate-activation-frame arity+1)))
                      (set-activation-frame-argument! v* arity '())
                      (set! *val* v*) ) )) ) ))
  (set! FINISH (lambda ()
                 (list (lambda () (*exit* *val*)))))
  )
;; --------------------------
